# -*- coding: utf-8 -*-

from wxPython.wx import *
import cPickle
import os, sys, copy
import wx.lib.plot as plot
from SpreadSheet import *

try:
	# heritage des propri�t�s de l'AtomicModel par domainBehavior 
	from PSDomain.Continuous 				import *
	from PSDomain.Sinks 					import *
	from PSDomain.Sources 					import *
	from PSDomain.Basic 					import *
	from DomainInterface.DomainBehavior 	import *
	from DomainInterface.DomainStructure 	import *
	from DomainInterface.MasterModel 		import *
	from PSDomain.PSSDB				 		import PSSDB
except:
	for spath in [os.pardir+os.sep]:
		if not spath in sys.path: sys.path.append(spath)
		
	from PSDomain.Continuous 				import *
	from PSDomain.Sinks 					import *
	from PSDomain.Sources 					import *
	from PSDomain.Basic 					import *
	from DomainInterface.MasterModel 		import *
	from DomainInterface.DomainBehavior 	import *
	from DomainInterface.DomainStructure 	import *
	from PSDomain.PSSDB				 		import PSSDB
	
#Global Stuff -------------------------------------------------
clipboard=[]

def menuMaker(frame, menus):
	menubar = wxMenuBar()
	for m,n in menus.items():
		menu = wxMenu()
		menubar.Append(menu,m)
		for x in n:
			id = wxNewId()
			menu.Append(id,x[0],x[1])
			EVT_MENU(frame, id, x[2])
	frame.SetMenuBar(menubar)

# -------------------------------------------------------------------
class MyModelDropTarget(wx.TextDropTarget):
	def __init__(self, obj=None, nb=None):
		""" 
		Constructor of MyModelDropTarget class
		
		@param obj: target objet (ShapeCanvas)
		@param nb: Notebook which contain model attributs
		
		@type obj: instance
		@type nb: instance
		"""
		wx.TextDropTarget.__init__(self)
		self.objet = obj
		self.nb=nb

	def OnDropText(self, x, y, text):
		# DEVS model
		devs = apply(eval(text+'.'+text),())
		# adding devs model on good graphical model
		if isinstance(devs,DomainBehavior):
			if str(devs)=="QuickScope":
				m=Scope()
			elif str(devs)=="To_Disk":
				m=Disk()
			else:
				m=CodeBlock()
			m.AddAtomicModel(devs)
			m.move(x-50,y-50)
		elif isinstance(devs,DomainStructure):
			m=ContainerBlock()
			m.AddCoupledModel(devs)
			m.move(x-50,y-50)
		elif isinstance(devs,IPort.IPort):
			m=iPort()
			m.move(x-70,y-70)
		elif isinstance(devs,OPort.OPort):
			m=oPort()
			m.move(x-70,y-70)
		else:
			print "Warnning, object not instantiated !"
		
		# Adding model propreties on noteBook page
		self.nb.DeletePage(1)
		self.nb.AddPage(AttributeEditor(self.nb,-1,"",m),"Properties")
		
		# Adding graphical model to diagram
		self.objet.AddShape(m)
		self.objet.deselect()
		self.objet.Refresh()
		
#-------------------------------------------------------------
class Diagram:
	def __init__(self):
		self.shapes=[]
		self.last_name_saved=""
		self.modify = False
		
	def SaveFile(self,fileName=None):
		if fileName is None:
			return
		try:
			cPickle.dump([self.shapes,self.coupledModel],open(fileName,'w'))
		except:
			print "problem saving this diagram"

	def LoadFile(self,fileName=None):
		if fileName is None:
			return
		try:
			L= cPickle.load(open(fileName))
			self.shapes, self.coupledModel = L 
		except:
			print "problem loading this diagram"

	def AddShape(self, shape, after=None):
		if after:
			self.shapes.insert(self.shapes.index(after),shape)
		else:
			self.shapes.insert(0, shape)
		self.modify = True
			
	def AppendShape(self, shape):
		self.shapes.append(shape)
		self.modify = True
		
	def InsertShape(self, shape, index=0):
		self.shapes.insert(index, shape)
		self.modify = True
	
	def DeleteShape(self,shape):
		#delete all shape links
		try:
			for cs in shape.connections:
				self.shapes.remove(cs)
		except:
				# passe pas parce que connections n'est pas vide
				pass
			# delete shape
		self.shapes.remove(shape)
		self.modify = True
	
	def PopShape(self,index=-1):
		return self.shapes.pop(index)

	def DeleteAllShapes(self):
		del self.shapes[:]
		self.modify = True

	def ChangeShapeOrder(self, shape, pos=0):
		self.shapes.remove(shape)
		self.shapes.insert(pos,shape)

	def GetCount(self):
		return len(self.shapes)
		
	def GetShapeList(self):
		return self.shapes


# Generic Shape Event Handler------------------------------------
class ShapeEvtHandler:

	def OnLeftUp(self,event):
		pass
		
	def OnLeftDown(self,event):
		pass
		
	def OnLeftDClick(self,event):
		pass

	def OnRightUp(self,event):
		pass
		
	def OnRightDown(self,event):
		pass
		
	def OnRightDClick(self,event):
		pass

	def OnSelect(self,event):
		pass
		
	def OnDeselect(self,event):
		pass
		
	def OnMove(self,event):
		pass
		
	def OnResize(self,event):
		pass
		
	def OnConnect(self,event):
		pass


# Generic Graphic items------------------------------------------
class Shape(ShapeEvtHandler):
	def __init__(self, x=[], y=[]):
		self.x = x                      # list of x coord
		self.y = y                      # list of y coords        
		self.pen = ['BLACK' , 1]    	# pen color and size
		self.fill= ['WHITE']            # fill color

	def draw(self,dc):
		dc.SetPen(wxPen(self.pen[0], self.pen[1], wxSOLID))
		dc.SetBrush(wxBrush(self.fill[0], wxSOLID))

	def move(self,x,y):
		self.x = map((lambda v: v+x), self.x)
		self.y = map((lambda v: v+y), self.y)

	
	def OnRightDown(self,event):
		pass
		
	def Copy(self):
		return copy.deepcopy(self)

#---------------------------------------------------------
class LineShape(Shape):
	def __init__(self,x1=20, y1=20, x2=50, y2=50):
		Shape.__init__(self, [x1,x2] ,  [y1,y2])
		

	def draw(self,dc):
		Shape.draw(self,dc)
		dc.DrawLine(self.x[0], self.y[0], self.x[1], self.y[1])
	
	def HitTest(self, x, y):
		if x < min(self.x)-3:return false
		if x > max(self.x)+3:return false
		if y < min(self.y)-3:return false
		if y > max(self.y)+3:return false
			
		top= (x-self.x[0]) *(self.x[1] - self.x[0]) + (y-self.y[0])*(self.y[1]-self.y[0])
		distsqr=pow(self.x[0]-self.x[1],2)+pow(self.y[0]-self.y[1],2)
		u=float(top)/float(distsqr)
		
		newx = self.x[0] + u*(self.x[1]-self.x[0])
		newy = self.y[0] + u*(self.y[1]-self.y[0])
	
		dist=pow(pow(newx-x,2) +  pow(newy-y,2),.5)

		if dist>7: return false
		return true

#---------------------------------------------------------
class RectangleShape(Shape):
	def __init__(self,x=20, y=20, x2=120, y2=120):
		Shape.__init__(self, [x,x2] ,  [y,y2])

	def draw(self,dc):
		Shape.draw(self,dc)
		dc.DrawRoundedRectangle(int(self.x[0]),
int(self.y[0]),int(self.x[1]-self.x[0]), int(self.y[1]-self.y[0]), 4.0)
		
	def HitTest(self, x, y):
		if x < self.x[0]: return false
		if x > self.x[1]: return false
		if y < self.y[0]: return false
		if y > self.y[1]: return false
		return true

#---------------------------------------------------------
class CircleShape(Shape):
	def __init__(self,x=20, y=20, x2=120, y2=120):
		Shape.__init__(self, [x,x2] ,  [y,y2])

	def draw(self,dc):
		Shape.draw(self,dc)
		dc.DrawCircle(int(self.x[0]+self.x[1])/2,int(self.y[0]+self.y[1])/2,30.0)
        dc.EndDrawing()
        
	def HitTest(self, x, y):
		if x < self.x[0]: return false
		if x > self.x[1]: return false
		if y < self.y[0]: return false
		if y > self.y[1]: return false
		return true
#---------------------------------------------------------
class PointShape(Shape):
	def __init__(self,x=20,y=20,size=4,type='rect'):
		Shape.__init__(self, [x] , [y])
		self.type=type
		self.size=size
		if self.type=='rect':
			self.graphic = RectangleShape(x-size,y-size,x+size,y+size)
		self.graphic.pen = self.pen
		self.graphic.fill = self.fill

	def moveto(self,x,y):
		self.x = x
		self.y = y
		size = self.size
		self.graphic.x=[x-size,x+size]
		self.graphic.y=[y-size,y+size]
		
	def move(self,x,y):
		self.x = map((lambda v: v+x), self.x)
		self.y = map((lambda v: v+y), self.y)
		self.graphic.move(x,y)

	def HitTest(self, x, y):
		return self.graphic.HitTest(x,y)

	def draw(self,dc):
		self.graphic.pen = self.pen
		self.graphic.fill = self.fill
		self.graphic.draw(dc)
		
#-------------------------------------------------------------
class ShapeCanvas(wxScrolledWindow):
	ID = 0
	def __init__(self,
		parent,
		id=-1,
		pos=(-1,-1),
		size=(-1,-1),
		style=0,
		name="",
		):
		wxScrolledWindow.__init__(self,parent,id,pos,size,style,name)
		self.diagram=None
		self.name = name
		self.nodes=[]
		self.currentPoint = [0,0] # x and y of last mouse click
		self.selectedShapes=[]
		self.scalex =1.0
		self.scaley =1.0
		self.SetScrollbars(100,100,100,100)
		ShapeCanvas.ID+=1
		
		#Window Events        
		EVT_PAINT(self, self.onPaintEvent)
		#Mouse Events
		EVT_LEFT_DOWN(self, self.OnLeftDown)
		EVT_LEFT_UP(self, self.OnLeftUp)
		EVT_LEFT_DCLICK(self, self.OnLeftDClick)
		
		EVT_RIGHT_DOWN(self, self.OnRightDown)
		EVT_RIGHT_UP(self, self.OnRightUp)
		EVT_RIGHT_DCLICK(self, self.OnRightDClick)
		
		EVT_MOTION(self, self.OnMotion)
		#Key Events
		EVT_KEY_DOWN(self,self.keyPress)
		
	def AddShape(self, shape, after=None):
		self.diagram.AddShape(shape,after)
			
	def AppendShape(self, shape):
		self.diagram.AppendShape(shape)
		
	def InsertShape(self, shape, index=0):
		self.diagram.InsertShape(shape,index)

	def DeleteShape(self,shape):
		self.diagram.DeleteShape(shape)
		
	def RemoveShape(self,shape):
		self.diagram.DeleteShape(shape)
	
	def keyPress(self,event):
		key = event.GetKeyCode()
		if key == 127:  # DELETE
			for s in self.select():
				self.diagram.DeleteShape(s)
			self.deselect() #remove nodes
		elif key == 67 and event.ControlDown():  # COPY
			del clipboard[:]
			for i in self.select():
				clipboard.append(i)
		elif key == 86 and event.ControlDown():  # PASTE
			for i in clipboard:
				self.AddShape(i.Copy())
		elif key == 9: # TAB
			if len(self.diagram.shapes)==0:
				return
			shape = self.select()
			if shape:
				ind = self.diagram.shapes.index(shape[0])
				self.deselect()
				try:
					self.select(self.diagram.shapes[ind+1])
				except:
					self.select(self.diagram.shapes[0])
			else:
					self.select(self.diagram.shapes[0])
		self.Refresh()

	def onPaintEvent(self, event):
		dc = wxPaintDC(self)
		self.PrepareDC(dc)
		dc.SetUserScale(self.scalex,self.scaley)
		dc.BeginDrawing()
		for item in self.diagram.shapes + self.nodes:
			item.draw(dc)
		dc.EndDrawing()

	def OnRightDown(self,event):
		self.getCurrentShape(event).OnRightDown(event)
	def OnRightUp(self,event):
		self.getCurrentShape(event).OnRightUp(event)
	def OnRightDClick(self,event):
		self.getCurrentShape(event).OnRightDClick(event)
	def OnLeftDClick(self,event):
		self.getCurrentShape(event).OnLeftDClick(event)
	def OnLeftDown(self,event):
		item = self.getCurrentShape(event)
		if item is None:   #clicked on empty space deselect all
			self.deselect()
			return
		
		item.OnLeftDown(event) # send leftdown event to current shape
		
		if isinstance(item,Selectable): 
			if not event.ShiftDown():self.deselect()
		
		self.select(item)
		self.Refresh()

	def OnLeftUp(self,event):
		try:
			shape = self.getCurrentShape(event)
			shape.OnLeftUp(event)
			shape.leftUp(self.select())
		except:
			pass 
		self.Refresh()
	
	def OnMotion(self,event):
		if event.Dragging():
			point = self.getEventCoordinates(event)
			x = point[0] - self.currentPoint[0]
			y = point[1] - self.currentPoint[1]
			for i in self.getSelectedShapes():
				i.move(x,y)
			self.currentPoint = point
			self.diagram.modify = True
			self.Refresh()
			
	def SetDiagram(self,diagram):
		self.diagram=diagram
		
	def GetDiagram(self):
		return self.diagram
	
	def getCurrentShape(self,event):
		# get coordinate of click in our coordinate system
		point = self.getEventCoordinates(event)
		self.currentPoint = point
		# Look to see if an item is selected
		for item in self.nodes + self.diagram.shapes:
			if item.HitTest(point[0],point[1]) :
				return item
		return None

	def getEventCoordinates(self, event):
		originX, originY = self.GetViewStart()
		unitX, unitY = self.GetScrollPixelsPerUnit()
		return [(event.GetX() + (originX * unitX)) / self.scalex, (event.GetY() + (originY * unitY))/ self.scaley]

	def getSelectedShapes(self):
		return self.selectedShapes

	def getName(self):
		return self.name
	
	def deselect(self,item=None):
		if item is None:
			for s in self.selectedShapes:
				s.OnDeselect(None)
			del self.selectedShapes[:]
			del self.nodes[:]
		else:
			self.nodes=[ n for n in self.nodes if n.item != item]
			self.selectedShapes = [ n for n in self.selectedShapes if n != item]
			item.OnDeselect(None)

	def select(self,item=None):
		if item is None:
			return self.selectedShapes
		
		if isinstance(item,Node):
			del self.selectedShapes[:]
			self.selectedShapes.append(item) # items here is a single node
			return
	
		if not item in self.selectedShapes:
			self.selectedShapes.append(item)
			item.OnSelect(None)
			if isinstance(item,Connectable):
				self.nodes.extend( [INode(item,n,self) for n in range(item.input)] )
				self.nodes.extend( [ONode(item,n,self) for n in range(item.output)] )
			if isinstance(item,Resizeable):
				self.nodes.extend( [ResizeableNode(item,n,self) for n in range(len(item.x))] )
			
	def showOutputs(self,item=None):
		if item:
			self.nodes.extend( [ONode(item,n,self) for n in range(item.output)])
		elif item is None:
			for i in self.diagram.shapes:
				if isinstance(i,Connectable):
					self.nodes.extend( [ONode(i,n,self) for n in
range(i.output)] )

	def showInputs(self,item=None):
		if isinstance(item,Block):
			self.nodes.extend( [INode(item,n,self) for n in range(item.input)] )
		else:
			for i in self.diagram.shapes:
				if isinstance(i,Connectable):
					self.nodes.extend( [INode(i,n,self) for n in range(i.input)])


#Abstract Classes------------------------------------------
class Selectable:
	'''
	Allows Shape to be selected
	'''
	def __init__(self):
		pass

#---------------------------------------------------------
class Resizeable:
	'''
	Creates resize Nodes that can be drug around the canvas
	to alter the shape or size of the Shape
	'''
	def __init__(self):
		pass
		
#---------------------------------------------------------
class Connectable:
	'''
	Creates connection nodes or ports 
	'''
	def __init__(self):
		self.input=1
		self.output=3
		self.connections=[] # this will be the list containing downstream connections
		self.direction="ouest"	# direction of ports (left)
		
	def getPort(self,type,num):
		
		# width and height of model
		w = self.x[1]-self.x[0]
		h = self.y[1]-self.y[0]
		
		if type=='input':
			div = float(self.input)+1.0
			x=self.x[0]
			
		elif type=='output':
			div = float(self.output)+1.0
			x=self.x[1]
		
		dx=float(w)/div
		dy=float(h)/div
		y= self.y[0]+dy*(num+1)
		
		# ouest -> nord
		if self.direction == "nord":
			if type=='input':
				x+=dx*(num+1)
				y-=dy*(num+1)
			else:
				x-=dx*(num+1)
				y+=h-dy*(num+1)
		# nord -> est
		elif self.direction == "est":
			if type=='input':
				x+=w
				y+=0
			else:
				x-=w
				y+=0
		# est -> sud
		elif self.direction == "sud":
			if type=='input':
				x+=dx*(num+1)
				y+=h-dy*(num+1)
			else:
				x-=dx*(num+1)
				y-=dy*(num+1)
		# sud -> ouest
		elif self.direction == "ouest":
			if type=='input':
				x+=0
				y+=0
			else:
				x+=0
				y+=0		
		
		return(x,y)
		
#---------------------------------------------------------
class Attributable:
	'''
	Allows AttributeEditor to edit specified properties
	of the Shape
	'''
	def __init__(self):
		self.attributes=[]

	def AddAttribute(self,name):
		self.attributes.append(name)

	def AddAttributes(self,atts):
		self.attributes.extend(atts)
		
	def RemoveAttribute(self,name):
		self.attributes.remove(name)

#-----------------------------------------------------------
class LinesShape(Shape,Resizeable):
	def __init__(self,points):
		Shape.__init__(self)
		self.x=[]
		self.y=[]
		for p in points:
			self.x.append(p[0])
			self.y.append(p[1])
		
	def draw(self,dc):
		Shape.draw(self,dc)
		ind = 0
		try:
			while 1:
				dc.DrawLine(self.x[ind], self.y[ind],self.x[ind+1],self.y[ind+1])
				ind+=1
		except:
			pass
		# pour la fleche
		dc.DrawRectanglePointSize(wxPoint(self.x[-1]-10/2,self.y[-1]-10/2),wxSize(10,10))
		
	def HitTest(self, x, y):
		
		if x < min(self.x)-3:return false
		if x > max(self.x)+3:return false
		if y < min(self.y)-3:return false
		if y > max(self.y)+3:return false
		
		ind=0
		try:
			while 1:
				x1=self.x[ind]
				y1=self.y[ind]
				x2=self.x[ind+1]
				y2=self.y[ind+1]
	
				top= (x-x1) *(x2 - x1) + (y-y1)*(y2-y1)
				distsqr=pow(x1-x2,2)+pow(y1-y2,2)
				u=float(top)/float(distsqr)
			
				newx = x1 + u*(x2-x1)
				newy = y1 + u*(y2-y1)
		
				dist=pow(pow(newx-x,2) + pow(newy-y,2),.5)
	
				if dist<7: 
					return true
				ind = ind +1
		except IndexError:
			pass
		
		return false

#---------------------------------------------------------
class Structurable:
	'''
	Structurable class interface for DEVS coupled model integration
	'''
	def __init__(self):
		""" Constructor of Structurable class interface
		"""
		self.coupledModel=None
		
	def AddCoupledModel(self,m):
		"""
		Add a DEVS coupled model instance to ContainerBlock
		
		@param m: DEVS coupled model
		@type m: instance
		"""
		self.coupledModel=m
		# synchronize the number of input and output port
		self.input=1
		self.output=1
		self.label=str(m)+" "+str(m.myID)
		
	def ConnectDEVSPorts(self,p1,p2):
		"""
		Connect DEVS ports
		
		@param p1: DEVS port
		@param p2: DEVS port
		
		@type p1: instance
		@type p2: instance
		"""
		assert(self.coupledModel != None)
		self.coupledModel.connectPorts(p1,p2)
		
	def ClearAllPorts(self):
		"""
		Clear all DEVS ports
		"""
		self.coupledModel.IC=[]
		self.coupledModel.EIC=[]
		self.coupledModel.EOC=[]
		
	def getDEVSModel(self):
		""" Return the DEVS coupled model.
		"""
		return self.coupledModel
	
	def setDEVSModel(self,m):
		"""
		Set the DEVS coupeld model.
		
		@param m: DEVS coupled model
		@type: instance
		"""
		self.coupledModel=m
	
#---------------------------------------------------------
class ConnectionShape(LinesShape,Resizeable,Selectable,Structurable):
	''' 
	'''
	def __init__(self):
		LinesShape.__init__(self,[(0,0),(1,1)])
		Resizeable.__init__(self)
		Selectable.__init__(self)
		Structurable.__init__(self)
		self.input = None
		self.output= None

	def setInput(self,item,index):
		self.input=(item,index)
		
	def setOutput(self,item,index):
		self.output=(item,index)
		
	def getInput(self):
		return self.input
	
	def getOutput(self):
		return self.output
		
	def draw(self,dc):
		if self.input:
			self.x[0],self.y[0] = self.input[0].getPort('output',self.input[1])
		if self.output:
			self.x[-1],self.y[-1] = self.output[0].getPort('input',self.output[1])
		LinesShape.draw(self,dc)
	
	def OnRightDown(self,event):
		
		# Rigth click menu
		menu = wx.Menu()
		for s in ['Delete']:
			exec 'id'+s+"="+str(wx.NewId())
	
		Delete_menu = menu.Append(idDelete, "Delete")
		
		self.canvas=event.GetEventObject()
		self.canvas.Bind(wx.EVT_MENU, self.OnDelete, Delete_menu)
		
		# show popUpMenu
		self.canvas.PopupMenu(menu, (event.GetX(),event.GetY()))

	def OnDelete(self, event):
		self.canvas.DeleteShape(self)
		self.canvas.Refresh()
		
	def OnLeftDClick(self,event):
		# faire l'ajout d'un noeud
		
		x,y=event.GetPositionTuple()
		
		# insertion sur les morceaux de droites d'affines
		for i in range(len(self.x)-1):
			x1=self.x[i]
			x2=self.x[i+1]
			y1=self.y[i]
			y2=self.y[i+1]
			
			b=float(y2-(x2/x1)*y1)/float(1-(x2/x1))
			a=float(y1-b)/x1
			
			# si le point (x,y) appartient au morceau
			if a*x+b-3 <= y <= a*x+b+3 :
				self.x.insert(i+1,x)
				self.y.insert(i+1,y)
				break
			
#---------------------------------------------------------
class Block(RectangleShape,Connectable,Resizeable,Selectable,Attributable):
	''' Generic Block class
	'''
	ID = 0
	def __init__(self):
		RectangleShape.__init__(self)
		Resizeable.__init__(self)
		Connectable.__init__(self)
		Attributable.__init__(self)
		self.AddAttributes(['label','pen','fill','input','output'])
		self.label='Block'
		Block.ID+=1
		
	def draw(self,dc):
		RectangleShape.draw(self,dc)
		w,h =  dc.GetTextExtent(self.label)
		mx=int((self.x[0] + self.x[1])/2.0 )-int(w/2.0)
		my=int((self.y[0]+self.y[1])/2.0)-int(h/2.0)
		dc.DrawText(self.label,mx,my)
		self.w=self.x[1]-self.x[0]
		self.h=self.y[1]-self.y[0]
		
	def OnLeftDown(self,event):
		if isinstance(self,Block) and event.ControlDown():
			d=wxTextEntryDialog(None,'Block Label',defaultValue=self.label,style=wxOK)
			d.ShowModal()
			self.label = d.GetValue()
		else:
			try:
				if (self.atomicModel != None):
					canvas=event.GetEventObject()
					nb = canvas.GetGrandParent().GetParent().nb1
					try:
						nb.DeletePage(1)
						nb.AddPage(AttributeEditor(nb,-1,"",self),"Properties")
					except IndexError:
						pass
			except AttributeError:
				pass
			
			try:
				if (self.coupledModel != None):
					canvas=event.GetEventObject()
					nb = canvas.GetGrandParent().GetParent().nb1
					try:
						nb.DeletePage(1)
						nb.AddPage(AttributeEditor(nb,-1,"",self),"Properties")
					except IndexError:
						pass
			except AttributeError:
				pass
			
	def OnRightDown(self,event):
	
		# Rigth click menu
		menu = wx.Menu()
		for s in ['AE', 'Rotate', 'Delete']:
			exec 'id'+s+"="+str(wx.NewId())
	
		AE_menu = menu.Append(idAE, "Edit")
		Rotate_menu = menu.Append(idRotate, "Rotate")
		Delete_menu = menu.Append(idDelete, "Delete")
		
		# give the NoteBook objet composed by Block object
		self.canvas=event.GetEventObject()
		nb = self.canvas.GetGrandParent().GetParent().nb2
		
		# binding notebook which contain Block model
		nb.Bind(wx.EVT_MENU, self.OnAE, AE_menu)
		nb.Bind(wx.EVT_MENU, self.OnRotate, Rotate_menu)
		nb.Bind(wx.EVT_MENU, self.OnDelete, Delete_menu)
		
		# show popUpMenu
		nb.PopupMenu(menu, (event.GetX(),event.GetY()))
	
	def OnRotate(self, event):
		if self.direction == "ouest":
			self.direction = "nord"
		elif self.direction == "nord":
			self.direction = "est"
		elif self.direction == "est":
			self.direction = "sud"
		else:
			self.direction = "ouest"
		
		self.canvas.Refresh()
			
	def OnAE(self, event):
		f = AttributeEditor(NULL, -1, "Attribute Editor",self)
		f.Show(true)
		
	def OnDelete(self, event):
		self.canvas.DeleteShape(self)
		self.canvas.Refresh()
		
#---------------------------------------------------------
class Achievable:
	'''
	Creates corresponding behavioral model
	'''
	def __init__(self):
		self.atomicModel=None
		
	def AddAtomicModel(self,m):
		#Add a corresponding behavioral model
		self.atomicModel=m
		# les port devs sont g�n�r�s dans la partie simltation en fonction du nombre de ports graphiques
		if 'Sources' in str(m.__class__).split('.'):
			self.input=0
			self.output=1
		elif 'Sinks' in str(m.__class__).split('.'):
			self.input=1
			self.output=0
		elif 'Continuous' in str(m.__class__).split('.'):
			self.input=1
			self.output=1
		elif 'Basic' in str(m.__class__).split('.'):
			self.input=1
			self.output=1
		else:
			self.input=3
			self.output=1
			
		self.label = str(m)+' '+str(CodeBlock.ID-1)
		
		self.AddAttributes(filter(lambda a: (a[0]=='_') and (a[-1]!='_') ,dir(self.atomicModel)))
	
	def getDEVSModel(self):
		return self.atomicModel
	
	def setDEVSModel(self,m):
		self.atomicModel=m
	
#---------------------------------------------------------
class CodeBlock(Block,Achievable):
	ID=0
	def __init__(self):
		CodeBlock.ID+=1
		Block.__init__(self)
		Achievable.__init__(self)
		self.AddAttribute('code')
		self.code=''
		
	def OnLeftDClick(self,event):
		exec str(self.code)
		
	def __del__(self):
		pass
		
#---------------------------------------------------------
class ContainerBlock(Block,Diagram,Structurable):
	ID=0
	def __init__(self):
		Block.__init__(self)
		Diagram.__init__(self)
		Structurable.__init__(self)
				
		ContainerBlock.ID+=1
		self.pen = ['BLACK' , 2]
		self.fill= ['GREEN']
		self.label='Coupled '+str(ContainerBlock.ID) 
		
	def OnLeftDClick(self,event):
		# creation du nouveau canvas
		canvas=event.GetEventObject().GetGrandParent().GetParent().OnNew(event)
		# r�cup�ration du nb2 qui contient toutes les pages droites
		nb=event.GetEventObject().GetGrandParent().GetParent().nb2
		# mise a jour du non de la page
		nb.SetPageText(nb.GetSelection(),self.label)
		# chargement du diagram du containerBlock
		canvas.SetDiagram(self)
	
	def __del__(self):
		pass
	
#---------------------------------------------------------

# Nodes
class Node(PointShape):
	def __init__(self,item,index,cf):
		self.item=item
		self.index = index
		self.cf = cf
		PointShape.__init__(self)
	
	def showProperties(self):
		self.item.showProperties

class ConnectableNode(Node):
	def __init__(self,item,index,cf):
		Node.__init__(self,item,index,cf)

class INode(ConnectableNode):
	def __init__(self,item,index,cf):
		ConnectableNode.__init__(self,item,index,cf)
		
	def leftUp(self,items):
		if len(items)==1 and isinstance(items[0],ConnectionShape):
			cs = items[0]
			if cs.output is None:
				cs.setOutput(self.item,self.index)
				# Add connectionShapes to graphical models
				self.item.connections.append(cs)
				cs.input[0].connections.append(cs)
					
	def move(self,x,y):
		self.cf.deselect()
		ci = ConnectionShape()
		self.cf.diagram.shapes.insert(0, ci)
		ci.setOutput(self.item,self.index)
		ci.x[0],ci.y[0] = self.item.getPort('input',self.index)
		self.cf.showOutputs()
		self.cf.select(ci)
	
	def draw(self,dc):
		x,y=self.item.getPort('input',self.index)
		self.moveto(x,y)
		self.fill= ['GREEN']
		PointShape.draw(self,dc)
		
class ONode(ConnectableNode):
	def __init__(self,item,index,cf):
		ConnectableNode.__init__(self,item,index,cf)
		
	def move(self,x,y):
		self.cf.deselect()
		ci = ConnectionShape()
		self.cf.diagram.shapes.insert(0, ci)
		ci.setInput(self.item,self.index)
		ci.x[1],ci.y[1] = self.item.getPort('output',self.index)
		self.cf.showInputs()
		self.cf.select(ci)

	def leftUp(self,items):
		if len(items)==1 and isinstance(items[0],ConnectionShape):
			cs = items[0]
			if cs.input is None:
				cs.setInput(self.item,self.index)
				# Add connectionShapes to graphical models
				self.item.connections.append(cs)
				cs.output[0].connections.append(cs)
		
	def draw(self,dc):
		x,y=self.item.getPort('output',self.index)
		self.moveto(x,y)
		self.fill= ['RED']
		PointShape.draw(self,dc)

class ResizeableNode(Node):
	def __init__(self,item,index,cf):
		Node.__init__(self,item,index,cf)
		self.fill=['BLACK']

	def draw(self,dc):
		item=self.item
		index=self.index
		try:
			self.moveto(item.x[index],item.y[index])
		except IndexError:
			pass
		PointShape.draw(self,dc)

	def move(self,x,y):
		self.item.x[self.index]+=x
		self.item.y[self.index]+=y
		
	def OnRightDown(self,event):
		
		if isinstance(self.item,ConnectionShape):
			# Rigth click menu
			menu = wx.Menu()
			for s in ['Delete']:
				exec 'id'+s+"="+str(wx.NewId())
		
			Delete_menu = menu.Append(idDelete, "Delete")
			
			self.canvas=event.GetEventObject()
			self.canvas.Bind(wx.EVT_MENU, self.OnDelete, Delete_menu)
			
			# show popUpMenu
			self.canvas.PopupMenu(menu, (event.GetX(),event.GetY()))

	def OnDelete(self, event):
		self.item.x.remove(self.x)
		self.item.y.remove(self.y)
		self.canvas.Refresh()
		
#---------------------------------------------------------
class Port(CircleShape,Connectable,Selectable,Attributable):
	''' Generic Port class
	'''
	ID = 0
	def __init__(self, x1, y1, x2, y2):
		CircleShape.__init__(self,x1,y1,x2,y2)
		Connectable.__init__(self)
		Selectable.__init__(self)
		Attributable.__init__(self)
		self.id=Port.ID
		Port.ID+=1
			
	def draw(self,dc):
		CircleShape.draw(self,dc)
		w,h =  dc.GetTextExtent(self.label)
		mx=int(self.x[0])+2
		my=int(self.y[1])
		dc.DrawText(self.label,mx, my)
		
	def OnLeftDown(self,event):
		if isinstance(self,Port) and event.ControlDown():
			d=wxTextEntryDialog(None,'Port Label',defaultValue=self.label,style=wxOK)
			d.ShowModal()
			self.label = d.GetValue()
		else:
			canvas=event.GetEventObject()
			nb = canvas.GetGrandParent().GetParent().nb1
			nb.DeletePage(1)
			nb.AddPage(AttributeEditor(nb,-1,"",self),"Properties")
			
	def OnRightDown(self,event):
		f = AttributeEditor(NULL, -1, "props",self)
		f.Show(true)
	
class iPort(Port):
	''' IPort class
	'''
	ID = 0
	def __init__(self):
		Port.__init__(self,50,60,100,120)
		self.AddAttributes(['pen','fill','id','label'])
		self.label='IPort '+ str(iPort.ID)
		self.input=0
		self.output=1
		self.id=0
		iPort.ID+=1
	
class oPort(Port):
	''' OPort class
	'''
	ID = 0
	def __init__(self):
		Port.__init__(self,50,60,100,120)
		self.AddAttributes(['pen','fill','id','label'])
		self.label='OPort '+ str(oPort.ID)
		self.input=1
		self.output=0
		self.id=0
		oPort.ID+=1
		
#------------------------------------------------------------
class AttributeEditor(wxFrame,wxPanel):
	def __init__(self, parent, ID, title, item):
		# pour g�rer l'affichage dans la page de gauche dans le notebook
		
		if isinstance(parent,wx.Notebook):
			wx.Panel.__init__(self, parent, ID)
			self.SetBackgroundColour(wxWHITE)
		else:
			wxFrame.__init__(self, parent, ID, title, wxDefaultPosition, wxSize(200, 450))

		self.item = item
		
		# Create a box sizer for self
		box = wxBoxSizer(wxVERTICAL)
		self.SetSizer(box)
		
		tID = wxNewId()
		self.list = wxListCtrl(self, tID, wxDefaultPosition, wxDefaultSize,
wxLC_REPORT)
		self.SetSize(self.GetSize())

		self.list.InsertColumn(0, "Attribute",format=wx.LIST_FORMAT_LEFT, width=100)
		self.list.InsertColumn(1, "Value",format=wx.LIST_FORMAT_LEFT, width=150)
		
		accept = wxButton(self, wxNewId(), "Accept",size=(40,30))
		
		for c in range(len(item.attributes)):
			self.list.InsertStringItem(c , "")
			self.list.SetStringItem(c, 0, str(item.attributes[c]))
			
			try:
				temp = str( eval("item." + str(item.attributes[c])))
			except AttributeError:
				if isinstance(self.item,Achievable):
					temp = str( eval("item.atomicModel." + str(item.attributes[c])))
				elif isinstance(self.item,Structurable):
					temp = str( eval("item.coupledModel." + str(item.attributes[c])))
					
			self.list.SetStringItem(c, 1, temp)
		
		self.text = wxTextCtrl(self,wxNewId(), "", style=wxTE_MULTILINE)
		
		box.Add(self.list, 1,wxEXPAND) 
		box.Add(accept, 0,wxEXPAND) 
		box.Add(self.text, 1,wxEXPAND) 
		
		EVT_LIST_ITEM_SELECTED(self.list,tID, self.selectProp)
		EVT_BUTTON(accept, accept.GetId(), self.acceptProp)
		
	def selectProp(self,event):
		idx=self.list.GetFocusedItem()
		prop = self.list.GetItem(idx,0).GetText()
		val = self.list.GetItem(idx,1).GetText()
		self.text.Clear()
		self.text.WriteText(val)
		
	def acceptProp(self,event):
		idx=self.list.GetFocusedItem()
		prop = self.list.GetItem(idx,0).GetText()
		lines = self.text.GetNumberOfLines()
		
		# gestion des attribut comportementaux
		if prop[0]=='_':
			if isinstance(self.item, Achievable):
				attr="self.item.atomicModel"
			else:
				attr="self.item.coupledModel"
		else:
			attr="self.item"
				
		if lines == 1:
			
			exec attr+"." + prop +'='+self.text.GetValue()
			
			if isinstance(self.item, Achievable):
				am=self.item.atomicModel	
				if prop == "input":
					try:
						am.delAllInPort()
						# add DEVS ports
						for i in range(self.item.input):
							am.addInPort()
					except AttributeError:
						pass
				elif prop == "output":
					try:
						am.delAllOutPort()
						# add DEVS ports
						for i in range(self.item.output):
							am.addOutPort()
					except AttributeError:
						pass
		else:
			p=setattr(self.item,prop,self.text.GetValue())
			
		self.list.SetStringItem(idx, 1, str(getattr(eval(attr),prop)))
#---------------------------------------------------------
class Plot(wxFrame):
	def __init__(self, parent=None, id=-1, title="Plotting",data=[]):
		wxFrame.__init__(self, parent, id, title, size=(800, 500))
		
		self.data = data
		client = plot.PlotCanvas(self)
		line = plot.PolyLine(data, legend='', colour='black', width=1)
		gc = plot.PlotGraphics([line], 'Line Graph', 'Time (s)', '')
		xMin,xMax=min([ c[0] for c in data ]),max([ c[0] for c in data ])
		yMin,yMax=min([ c[1] for c in data ]),max([ c[1] for c in data ])
		client.Draw(gc,  xAxis= (xMin,xMax), yAxis= (yMin,yMax))
		self.Show(True)
  		EVT_CLOSE(self, self.OnQuit)
		
	def OnQuit(self, event):
		self.Destroy()

class Scope(CodeBlock):
	def __init__(self):
		CodeBlock.__init__(self)
		
	def OnLeftDClick(self,event):
		frame=Plot(None,-1,"Plotting "+self.label,self.atomicModel.results[0])
		frame.Show(True)
		frame.Center()

class Disk(CodeBlock):
	def __init__(self):
		CodeBlock.__init__(self)
		
	def OnLeftDClick(self,event):
		frame=Newt(None, -1, "SpreadSheet "+self.label,self.atomicModel.results[0])
		frame.Show(True)
		frame.Center()
		
#---------------------------------------------------------
class CodeFrame(wxFrame):
	def __init__(self,diagram):
		wxFrame.__init__(self,None, -1, 'ModEnv', wxDefaultPosition, wxSize(500,300))
		
		self.Center()
		
		self.file=None
		menus={}

		#menus['&Add']=[
			#('Code' , "Block that holds code",self.newCodeBlock),
			#('Container', 'Block that holds blocks', self.newContBlock),
			#('Point', 'Playing with points', self.newPointShape),
			#('Lines', 'Plotting', self.newLinesShape),
			#]

		menus['&Zoom']=[
			('Zoom In\tCtrl+o' , "zoom in",self.zoomin),
			('Zoom Out\tCtrl+p' , "zoom out",self.zoomout),
			]

		menuMaker(self,menus)

		# Canvas Stuff
		self.canvas=ShapeCanvas(self,-1)
		self.canvas.SetDiagram(diagram)
		self.canvas.SetBackgroundColour(wxWHITE)

		self.Show(true)

	def zoomin(self,event):
		self.canvas.scalex=max(self.canvas.scalex+.05,.3)
		self.canvas.scaley=max(self.canvas.scaley+.05,.3)
		self.canvas.Refresh()

	def zoomout(self,event):
		self.canvas.scalex=self.canvas.scalex-.05
		self.canvas.scaley=self.canvas.scaley-.05
		self.canvas.Refresh()

	def newCodeBlock(self, event):
		i = CodeBlock()
		self.canvas.AddShape(i)
		self.canvas.deselect()
		self.canvas.Refresh()

	def newContBlock(self, event):
		i = ContainerBlock()
		self.canvas.AddShape(i)
		self.canvas.deselect()
		self.canvas.Refresh()
				
	def newPointShape(self, event):
		i = PointShape(50,50)
		self.canvas.AddShape(i)
		self.canvas.deselect()
		self.canvas.Refresh()
		
	def newLinesShape(self, event):
		points=[
			(5,30),(10,20),(20,25),(30,50),(40,70),
			(50,30),(60,20),(70,25),(80,50),(90,70),
			(100,30),(110,20),(115,25),(120,50),(125,70),
			(130,30),(135,20),(140,25),(150,50),(160,70),
			(165,30),(170,20),(175,25),(180,50),(200,70),
			]
		i = LinesShape(points)
		self.canvas.AddShape(i)
		self.canvas.deselect()
		self.canvas.Refresh()

class MyApp(wxApp):
	def OnInit(self):
		frame = CodeFrame(ContainerBlock())
		frame.newContBlock(self)
		frame.newContBlock(self)		

		#for c in frame.canvas.diagram.shapes:
			#print c.label
			
		return true

########################################

if __name__ == '__main__':
	app = MyApp(0)
	app.MainLoop()